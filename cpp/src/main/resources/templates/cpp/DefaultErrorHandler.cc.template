\#if (JAVACC_CHAR_TYPE_SIZEOF != 1)
\#include <codecvt>
\#include <locale>
\#endif
\#include "JavaCC.h"
\#include "Token.h"
\#include "DefaultErrorHandler.h"

#if NAMESPACE
namespace ${NAMESPACE_OPEN}
#fi

\#if (JAVACC_CHAR_TYPE_SIZEOF != 1)
using convert_t = std::codecvt_utf8<wchar_t>;
static std::wstring_convert<convert_t, wchar_t> strconverter;

static std::string to_string(const std::wstring& wstr)
{
    return strconverter.to_bytes(wstr);
}

static std::wstring to_wstring(const std::string& str)
{
    return strconverter.from_bytes(str);
}
\#endif

#if BUILD_PARSER
      
void DefaultErrorHandler::handleUnexpectedToken(int expectedKind, const JJString& expectedImage, const JJString& expectedLabel, const Token* actual) {
	error_count++;
	JAVACC_CLOG 
       << JAVACC_WIDE(Expecting) << JJSPACE << addUnicodeEscapes(expectedLabel) << JAVACC_WIDE(:) << JJQUOTE << addUnicodeEscapes(expectedImage) << JJQUOTE
       << JJSPACE << JAVACC_WIDE(at) << JJSPACE << actual->beginLine() << JAVACC_WIDE(:) << actual->beginColumn() << JJSPACE 
       << JAVACC_WIDE(but got) << JJSPACE << JJQUOTE << addUnicodeEscapes(actual->image()) << JJQUOTE << std::endl;
}
      
      
void DefaultErrorHandler::handleParseError(const Token* last, const Token* unexpected, const JJSimpleString& production) {
    error_count++;
\#if (JAVACC_CHAR_TYPE_SIZEOF == 1)
    const JJString& work = production;
\#else
    const JJString& work = to_wstring(production);
\#endif
    JAVACC_CLOG 
        << JAVACC_WIDE(Encountered:) << JJSPACE << JJQUOTE << addUnicodeEscapes(unexpected->image()) << JJQUOTE << JJSPACE 
        << JAVACC_WIDE(at) << JJSPACE << unexpected->beginLine() << JAVACC_WIDE(:) << unexpected->beginColumn()  << JJSPACE 
        << JAVACC_WIDE(while parsing:) << JJSPACE << work << std::endl;
}
      
void DefaultErrorHandler::handleOtherError(const JJString& message) {
    JAVACC_CLOG << JAVACC_WIDE(Error:) << JJSPACE  << message << std::endl;
}
#fi

#if BUILD_TOKEN_MANAGER
void DefaultTokenManagerErrorHandler::lexicalError(bool EOFSeen, int lexState, int errorLine, int errorColumn, JJString errorAfter, JJChar curChar) {
    JAVACC_CLOG 
      << JAVACC_WIDE(Lexical error at)  << JJSPACE << errorLine << JAVACC_WIDE(:) << errorColumn << JAVACC_WIDE(.)
      << JAVACC_WIDE( Encountered:)  << JJSPACE << curChar <<JAVACC_WIDE( after:)  << JJSPACE << errorAfter << JAVACC_WIDE(.) << std::endl;
}
      
void DefaultTokenManagerErrorHandler::lexicalError(const JJString& errorMessage) {
    JAVACC_CLOG << errorMessage << std::endl;
}
#fi

#if NAMESPACE
${NAMESPACE_CLOSE}
#fi
